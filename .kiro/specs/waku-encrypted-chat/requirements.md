# Waku 加密聊天 SDK 需求文档

## 概述

基于 Waku 去中心化 P2P 通信协议族，封装一个"最小可用"的加密聊天层，包含 Chat SDK 库和 CLI/Web Demo。

## 用户故事与验收标准

### 1. 身份与会话管理

#### 1.1 用户身份创建与持久化
作为用户，我希望能够创建并持久化我的身份，以便在不同会话中保持一致的身份标识。

**验收标准：**
- 系统生成基于 secp256k1 的密钥对作为用户身份
- 密钥对可导出为加密的 JSON 格式并持久化存储
- 支持从持久化存储恢复身份
- 每个用户有唯一的 userId（基于公钥派生）

#### 1.2 单聊会话创建
作为用户，我希望能够与另一个用户创建单聊会话，以便进行一对一的私密通信。

**验收标准：**
- 通过对方 userId 创建单聊会话
- 单聊会话 ID 由双方 userId 确定性生成（排序后哈希）
- 会话创建后自动订阅对应的 content topic
- 支持会话元数据存储（创建时间、参与者等）

#### 1.3 群聊会话创建与加入
作为用户，我希望能够创建或加入群聊会话，以便与多人同时通信。

**验收标准：**
- 创建群聊时生成唯一群组 ID
- 创建者自动成为群管理员
- 其他用户可通过群组 ID 加入群聊
- 群聊支持成员列表管理
- 支持离开群聊功能

### 2. 消息发送与接收

#### 2.1 发送消息
作为用户，我希望能够向会话发送加密消息，以便与其他参与者安全通信。

**验收标准：**
- sendMessage(conversationId, plaintext) 返回 messageId
- 消息使用会话密钥加密后发送
- 消息包含发送者签名以验证完整性
- 支持基本重试机制（最多 3 次）
- 发送超时返回错误提示

#### 2.2 接收消息
作为用户，我希望能够实时接收会话中的消息，以便及时获取通信内容。

**验收标准：**
- subscribe(conversationId, handler) 注册消息回调
- 收到消息后验证签名和解密
- 基于 messageId 进行去重处理
- 支持取消订阅功能

#### 2.3 消息格式定义
作为开发者，我需要明确的消息格式定义，以便正确解析和处理消息。

**验收标准：**
- 使用 Protobuf 定义消息格式
- 消息包含：messageId、senderId、timestamp、type、payload、signature
- 支持消息版本号以便未来升级
- 控制消息（撤回/系统通知）使用相同格式但不同 type

### 3. 历史消息

#### 3.1 拉取历史消息
作为用户，我希望能够拉取会话的历史消息，以便查看之前的通信记录。

**验收标准：**
- 使用 Waku Store 节点拉取历史消息
- 支持分页查询（指定起止时间或数量）
- 历史消息同样需要解密和验证
- 已撤回的消息在历史中标记为已撤回

### 4. 删除与撤回

#### 4.1 本地删除
作为用户，我希望能够删除本地的消息，以便清理我不想看到的内容。

**验收标准：**
- 本地删除仅影响当前设备
- 删除后消息从本地存储移除
- 不发送任何网络消息
- 其他设备和用户不受影响

#### 4.2 消息撤回
作为用户，我希望能够撤回我发送的消息，以便其他参与者不再看到该消息。

**验收标准：**
- 发送撤回控制消息（tombstone）
- 控制消息包含被撤回的 messageId
- 控制消息包含发送者签名以验证权限
- 只有原发送者或群管理员可撤回消息
- 其他客户端收到后将消息标记为"已撤回"
- 撤回后的消息显示为"此消息已被撤回"

#### 4.3 撤回权限验证
作为系统，我需要验证撤回请求的合法性，以防止恶意撤回。

**验收标准：**
- 验证撤回请求的签名
- 单聊中只有原发送者可撤回
- 群聊中原发送者或管理员可撤回
- 非法撤回请求被忽略

### 5. 安全机制

#### 5.1 消息加密
作为用户，我希望消息在传输和存储时都是加密的，以保护通信隐私。

**验收标准：**
- 使用 AES-256-GCM 对消息 payload 加密
- 每条消息使用唯一的 nonce
- 密钥派生使用 HKDF
- 加密后的消息无法被未授权方解读

#### 5.2 消息完整性
作为用户，我希望能够验证消息未被篡改，以确保通信安全。

**验收标准：**
- 每条消息包含发送者的 ECDSA 签名
- 签名覆盖消息的关键字段
- 接收方验证签名后才处理消息
- 签名验证失败的消息被丢弃

#### 5.3 密钥交换
作为系统，我需要安全的密钥交换机制，以建立会话密钥。

**验收标准：**
- 单聊使用 ECDH 派生共享密钥
- 群聊使用群组密钥（创建时生成，加入时分发）
- 密钥交换消息本身使用接收者公钥加密
- 支持密钥更新机制

### 6. Waku 协议集成

#### 6.1 Relay 模式
作为系统，我需要支持 Relay 模式进行消息传输。

**验收标准：**
- 连接到 Waku Relay 网络
- 使用统一的 pubsub topic：/waku/2/encrypted-chat/proto
- 每个会话使用独立的 content topic
- 支持消息发布和订阅

#### 6.2 Light Push + Filter 模式
作为资源受限的客户端，我希望能够使用轻节点模式。

**验收标准：**
- 支持 Light Push 发送消息
- 支持 Filter 订阅消息
- 自动发现并连接 Light 协议节点
- 在资源受限环境下正常工作

#### 6.3 Store 协议集成
作为系统，我需要集成 Store 协议以支持历史消息。

**验收标准：**
- 连接到 Store 节点
- 支持按 content topic 查询历史
- 支持时间范围和数量限制
- 正确处理分页响应

### 7. 可靠性机制

#### 7.1 消息去重
作为系统，我需要确保消息不会重复处理。

**验收标准：**
- 基于 messageId 进行去重
- 维护已处理消息 ID 的缓存
- 重复消息被静默丢弃
- 缓存有合理的过期策略

#### 7.2 消息重发
作为系统，我需要在发送失败时自动重试。

**验收标准：**
- 发送失败后自动重试（最多 3 次）
- 重试间隔指数退避
- 最终失败返回错误给调用方
- 重发使用相同的 messageId

### 8. Demo 应用

#### 8.1 CLI Demo
作为开发者，我需要一个 CLI Demo 来测试 SDK 功能。

**验收标准：**
- 支持创建/恢复身份
- 支持创建/加入单聊和群聊
- 支持发送和接收消息
- 支持撤回和删除消息
- 支持查看历史消息
- 提供交互式命令行界面

#### 8.2 Web Demo
作为用户，我需要一个 Web Demo 来可视化测试功能。

**验收标准：**
- 提供简洁的聊天界面
- 支持所有 SDK 功能
- 实时显示消息状态
- 撤回的消息显示为"已撤回"
- 支持多会话切换

### 9. 测试与文档

#### 9.1 自动化测试
作为开发者，我需要自动化测试来验证功能正确性。

**验收标准：**
- 单聊互发测试
- 群聊广播测试
- 撤回后各端一致显示测试
- 加密解密测试
- 签名验证测试

#### 9.2 设计文档
作为开发者，我需要详细的设计文档来理解系统架构。

**验收标准：**
- 说明 pubsub topic 与 content topic 的区别和用法
- 说明 Relay vs LightPush/Filter 的选择依据
- 说明消息唯一标识方案
- 说明撤回/删除在去中心化网络中的边界
- 说明加密方案和密钥管理

### 10. 本地测试环境

#### 10.1 一键启动环境
作为开发者，我需要能够一键启动本地测试环境。

**验收标准：**
- 提供 Docker Compose 或脚本启动本地 nwaku 节点
- 至少启动 3 个节点组成测试网络
- 提供演示脚本展示 2 用户单聊 + 3 用户群聊
- README 包含完整的启动和演示步骤

## 技术约束

- 使用 TypeScript 开发
- 使用 @waku/sdk 作为 Waku 客户端
- 使用 Protobuf 定义消息格式
- 使用 Node.js 18+ 运行环境
- Web Demo 使用 React 或 Vue

## 关键概念说明（需在设计文档中详细阐述）

1. **pubsub topic vs content topic**：pubsub topic 是路由层概念，决定消息在哪些节点间传播；content topic 是应用层概念，用于过滤和分类消息。

2. **Relay vs LightPush/Filter**：Relay 是全节点模式，参与消息路由；LightPush/Filter 是轻节点模式，依赖服务节点，适合资源受限场景。

3. **消息唯一标识**：使用 Waku 的 messageHash 或自定义方案（timestamp + senderId + random），需保证全局唯一且可追溯。

4. **撤回/删除的边界**：去中心化网络无法强制所有节点删除已传播的消息，只能通过控制消息实现"逻辑删除"，已接收但未处理撤回的客户端仍可能看到原消息。
